<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WAV Audio Editor</title>

    <!-- Wavesurfer.js and Plugins -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/wavesurfer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/plugin/wavesurfer.regions.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/plugin/wavesurfer.timeline.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/plugin/wavesurfer.cursor.min.js"></script>

    <!-- LAME MP3 Encoder REMOVED -->

    <style>
        :root { --primary-color: #2a9d8f; --secondary-color: #1a2933; --background-color: #121212; --control-color: #457b9d; --highlight-color: #e76f51; --text-color: #e0e0e0; --button-hover: #1d7268; --control-hover: #3a6a8a; --danger-hover: #c7563a; --card-bg: #1e1e1e; --border-color: #333; }
        body { font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: var(--background-color); color: var(--text-color); padding-bottom: 60px; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background-color: var(--secondary-color); color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; border-radius: 5px 5px 0 0; flex-wrap: wrap; gap: 10px; }
        .title { font-size: 24px; font-weight: bold; flex-shrink: 0; }
        .file-info { font-size: 14px; text-align: right; flex-grow: 1; word-break: break-word; }
        .waveform-container { background-color: var(--card-bg); border-radius: 5px; margin: 20px 0; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); border: 1px solid var(--border-color); position: relative; }
        #waveform { margin-bottom: 10px; background-color: #2a2a2a; border-radius: 3px; min-height: 100px; }
        #timeline { margin-bottom: 10px; height: 20px; min-height: 20px; }
        #time-display { text-align: center; font-size: 16px; margin-bottom: 20px; color: #ccc; min-height: 1.2em; }
        .transport-controls { display: flex; justify-content: center; flex-wrap: wrap; margin-bottom: 20px; gap: 10px; }
        .save-options { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 10px; }
        .control-panel { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .control-group { background-color: var(--card-bg); border-radius: 5px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); border: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .control-group h3 { margin-top: 0; margin-bottom: 15px; color: var(--primary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        .control-group .button-group { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
        .btn { background-color: var(--control-color); color: white; border: none; border-radius: 4px; padding: 8px 15px; cursor: pointer; font-size: 14px; transition: background-color 0.2s, opacity 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 5px; text-align: center; }
        .btn:hover { background-color: var(--control-hover); }
        .btn:disabled { background-color: #555; color: #aaa; cursor: not-allowed; opacity: 0.6; }
        .btn:disabled:hover { background-color: #555; }
        .btn-primary { background-color: var(--primary-color); }
        .btn-primary:hover { background-color: var(--button-hover); }
        .btn-primary:disabled { background-color: #555; opacity: 0.6; }
        .btn-primary:disabled:hover { background-color: #555; }
        .btn-danger { background-color: var(--highlight-color); }
        .btn-danger:hover { background-color: var(--danger-hover); }
        .btn-danger:disabled { background-color: #555; opacity: 0.6; }
        .btn-danger:disabled:hover { background-color: #555; }
        .slider-container { margin: 15px 0; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .slider-container label { flex-shrink: 0; width: 100px; font-size: 14px; }
        .slider-container input[type="range"] { width: 100%; cursor: pointer; flex-grow: 1; min-width: 100px; height: 5px; }
        .slider-value { font-weight: bold; min-width: 60px; text-align: right; color: #ccc; font-size: 14px; }
        input[type="range"]:disabled { cursor: not-allowed; opacity: 0.6; }
        .file-drop { border: 2px dashed #555; border-radius: 5px; padding: 35px 25px; text-align: center; margin-bottom: 20px; background-color: rgba(30,30,30,0.8); transition: border-color 0.2s, background-color 0.2s; color: var(--text-color); cursor: pointer; }
        .file-drop.active { border-color: var(--primary-color); background-color: rgba(42,157,143,0.2); }
        .file-drop p { margin: 0; font-size: 16px; color: #bbb; }
        .status-bar { background-color: var(--secondary-color); color: white; padding: 10px 20px; text-align: center; position: fixed; bottom: 0; left: 0; width: 100%; box-sizing: border-box; font-size: 14px; z-index: 1000; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        #processing-overlay { position: fixed; inset: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 2000; color: white; font-size: 1.2em; flex-direction: column; padding: 20px; box-sizing: border-box; text-align: center; pointer-events: auto; }
        #processing-overlay .progress-container { width: 80%; max-width: 400px; margin-top: 15px; height: 12px; background-color: #555; border-radius: 6px; overflow: hidden; display: block; }
        #processing-overlay .progress-bar { width: 0%; height: 100%; background-color: var(--primary-color); border-radius: 6px; transition: width 0.1s linear; }
        .attribution { text-align: center; font-size: 12px; color: #888; margin-top: 30px; }

        @media (max-width: 768px) { .control-panel { grid-template-columns: 1fr; } .header { gap: 5px; } .title { font-size: 20px; } .file-info { font-size: 12px; text-align: left; width: 100%; } .transport-controls { justify-content: space-around; } .slider-container { gap: 5px; } .slider-container label { width: 90px; } .slider-value { min-width: 60px; text-align: right; } }
        @media (max-width: 480px) { .transport-controls .btn, .control-group .button-group .btn, .save-options .btn { padding: 6px 10px; font-size: 12px; flex-grow: 1; flex-basis: 60px; } .transport-controls, .save-options { gap: 5px; } .title { font-size: 18px; } .file-drop p { font-size: 14px; } .slider-container { gap: 8px; flex-direction: column; align-items: stretch; } .slider-container label { width: 100%; text-align: left; margin-bottom: 3px; } .slider-container > div { display: flex; width: 100%; align-items: center; gap: 10px; } .slider-container input[type="range"] { min-width: auto; flex-grow: 1; margin-right: 10px; } .slider-value { text-align: right; flex-basis: 60px; flex-shrink: 0; } .status-bar { font-size: 12px; } .attribution { margin-top: 20px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">WAV Audio Editor</div>
            <div class="file-info" id="file-info">No file loaded</div>
        </div>

        <div class="file-drop" id="file-drop">
            <p>Drag & drop a WAV file here or click to select</p>
            <input type="file" id="file-input" accept=".wav,audio/wav,audio/wave" style="display:none" />
        </div>

        <div class="waveform-container">
            <div id="waveform"></div>
            <div id="timeline"></div>
            <div id="time-display">0:00 / 0:00</div>
        </div>

        <div class="transport-controls">
            <button class="btn" id="play-btn" disabled title="Play/Pause">‚ñ∂Ô∏è Play</button>
            <button class="btn" id="pause-btn" disabled title="Pause">‚è∏Ô∏è Pause</button>
            <button class="btn" id="stop-btn" disabled title="Stop">‚èπÔ∏è Stop</button>
            <button class="btn" id="loop-btn" disabled title="Toggle loop playback">Loop: Off</button>
        </div>

        <!-- Save Options Grouped -->
        <div class="save-options control-group" style="margin-top: -10px; margin-bottom: 20px; padding-top: 5px;">
             <h3 style="margin-bottom: 10px;">Save Options</h3>
             <div class="button-group">
                 <button class="btn btn-primary" id="save-wav-44-btn" disabled title="Save current audio as WAV (44.1kHz)">üíæ Save WAV (44.1kHz)</button>
                 <button class="btn btn-primary" id="save-wav-48-btn" disabled title="Save current audio as WAV (48kHz)">üíæ Save WAV (48kHz)</button>
                 <!-- MP3 Button Removed -->
            </div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <h3>Selection</h3>
                <div class="button-group">
                    <button class="btn" id="select-all-btn" disabled title="Select the entire audio track">Select All</button>
                    <button class="btn" id="select-none-btn" disabled title="Remove the current selection">Deselect</button>
                    <button class="btn btn-danger" id="cut-btn" disabled title="Remove the selected audio region">Cut Selection</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Effects</h3>
                 <div class="button-group">
                    <button class="btn" id="reverse-btn" disabled title="Reverse audio">Reverse</button>
                    <button class="btn" id="normalize-btn" disabled title="Maximize volume">Normalize</button>
                 </div>

                 <div class="slider-container">
                   <label for="gain-adjust" title="Adjust volume (-24dB to +24dB)">Gain:</label>
                    <div style="display: flex; width: 100%; align-items: center; gap: 10px;">
                       <input type="range" id="gain-adjust" min="-24" max="24" value="0" step="0.5" disabled />
                       <span class="slider-value" id="gain-adjust-value">0 dB</span>
                    </div>
                 </div>
                 <button class="btn" id="gain-apply-btn" disabled title="Apply gain setting">Apply Gain</button>

                 <div class="button-group" style="margin-top: 15px;">
                     <button class="btn" id="fade-in-btn" disabled title="Apply fade-in">Fade In</button>
                     <button class="btn" id="fade-out-btn" disabled title="Apply fade-out">Fade Out</button>
                 </div>
            </div>

            <div class="control-group">
                <h3>Display</h3>
                <div class="slider-container">
                    <label for="zoom-slider" title="Zoom waveform">Zoom:</label>
                     <div style="display: flex; width: 100%; align-items: center; gap: 10px;">
                        <input type="range" id="zoom-slider" min="0" max="500" value="0" disabled/>
                        <span class="slider-value" id="zoom-value">0</span>
                     </div>
                </div>
            </div>
        </div>

        <!-- Attribution -->
        <div class="attribution">
            Written by Jonas Lund 2025
        </div>

        <div id="processing-overlay" style="display: none;">
            <span id="processing-message">Processing...</span>
            <div class="progress-container" id="processing-progress-container"> <div class="progress-bar" id="processing-progress-bar"></div> </div>
        </div>
    </div>
    <div class="status-bar" id="status-bar">Ready</div>

    <script>
        // --- Global Variables ---
        let wavesurfer = null; let audioContext = null; let originalBuffer = null;
        let currentBuffer = null; let loopEnabled = false; let currentFileName = "No file loaded";

        // --- DOM Element References ---
        let fileDropElement, fileInputElement, fileInfoElement, statusBarElement; let timeDisplayElement;
        let gainAdjustSlider, gainAdjustValue; let zoomSlider, zoomValue;
        let processingOverlay, processingMessage, processingProgressContainer, processingProgressBar;
        let allButtonsAndSliders;

        // --- Init Functions ---
        function initDomReferences() { fileDropElement = document.getElementById("file-drop"); fileInputElement = document.getElementById("file-input"); fileInfoElement = document.getElementById("file-info"); statusBarElement = document.getElementById("status-bar"); timeDisplayElement = document.getElementById("time-display"); processingOverlay = document.getElementById("processing-overlay"); processingMessage = document.getElementById("processing-message"); processingProgressContainer = document.getElementById("processing-progress-container"); processingProgressBar = document.getElementById("processing-progress-bar"); gainAdjustSlider = document.getElementById("gain-adjust"); gainAdjustValue = document.getElementById("gain-adjust-value"); zoomSlider = document.getElementById("zoom-slider"); zoomValue = document.getElementById("zoom-value"); allButtonsAndSliders = document.querySelectorAll('.btn, input[type="range"]'); console.log("DOM references initialized."); }
        function initWaveSurfer() { const wfCont = document.getElementById("waveform"), tlCont = document.getElementById("timeline"); if (!wfCont || !tlCont) { console.error("Waveform/Timeline container not found!"); setStatus("Error: UI elements missing."); return; } try { wavesurfer = WaveSurfer.create({ container: wfCont, waveColor: "rgba(100, 160, 200, 0.8)", progressColor: "#2a9d8f", cursorColor: "#e76f51", cursorWidth: 2, height: 140, normalize: true, responsive: true, plugins: [ WaveSurfer.regions.create({ dragSelection: true, color: "rgba(231, 111, 81, 0.3)", handleStyle: { left: { backgroundColor: '#e76f51' }, right: { backgroundColor: '#e76f51' } }, loop: false }), WaveSurfer.timeline.create({ container: tlCont, primaryFontColor: "#ccc", secondaryFontColor: "#999", primaryColor: "#777", secondaryColor: "#555", height: 20 }), WaveSurfer.cursor.create({ showTime: true, opacity: 1, customShowTimeStyle: { "background-color": "#000", color: "#fff", padding: "2px 4px", "font-size": "10px", "border-radius": "2px" } }) ] }); console.log("WaveSurfer instance created."); wavesurfer.on("ready", () => { console.log("WaveSurfer ready."); updateFileInfo(); setStatus(`File loaded: ${currentFileName}`); if (zoomSlider) zoomSlider.value = 0; if (zoomValue) zoomValue.textContent = '0'; wavesurfer.zoom(0); updateTimeDisplay(); hideProcessing(); enableControls(); }); wavesurfer.on("audioprocess", updateTimeDisplay); wavesurfer.on("seek", updateTimeDisplay); wavesurfer.on("play", () => { setStatus("Playing"); enableControls(); }); wavesurfer.on("pause", () => { setStatus("Paused"); enableControls(); }); wavesurfer.on("stop", () => { setStatus("Stopped"); enableControls(); updateTimeDisplay(); wavesurfer.seekTo(0); }); wavesurfer.on("finish", () => { const region = getSelectedRegion(); if (loopEnabled) { if (region) setTimeout(() => wavesurfer?.play(region.start), 50); else setTimeout(() => wavesurfer?.play(), 50); } else { setStatus("Finished playing"); wavesurfer?.seekTo(0); enableControls(); updateTimeDisplay(); } }); wavesurfer.on("region-created", region => { const regions = wavesurfer.regions.list; Object.keys(regions).forEach(id => { if (id !== region.id) regions[id].remove(); }); region.loop = loopEnabled; enableControls(); }); wavesurfer.on("region-updated", region => { region.loop = loopEnabled; enableControls(); }); wavesurfer.on("region-dblclick", (region, event) => { event.stopPropagation(); wavesurfer?.play(region.start, region.end); setStatus(`Playing selection (${formatTime(region.start)} - ${formatTime(region.end)})`); }); wavesurfer.on("region-removed", () => enableControls()); wavesurfer.on("error", errorMsg => { setStatus(`WaveSurfer Error: ${errorMsg}`); console.error("WaveSurfer Error:", errorMsg); currentBuffer = null; originalBuffer = null; updateFileInfo(); updateTimeDisplay(); hideProcessing(); enableControls(); }); } catch (error) { console.error("Error initializing WaveSurfer:", error); setStatus("Fatal Error: Could not initialize audio waveform display."); enableControls(); } }
        function initEventListeners() { if (fileDropElement) { fileDropElement.addEventListener("click", () => fileInputElement?.click()); fileDropElement.addEventListener("dragover", e => { e.preventDefault(); e.stopPropagation(); fileDropElement.classList.add("active"); }); fileDropElement.addEventListener("dragleave", e => { e.preventDefault(); e.stopPropagation(); fileDropElement.classList.remove("active"); }); fileDropElement.addEventListener("drop", e => { e.preventDefault(); e.stopPropagation(); fileDropElement.classList.remove("active"); if (e.dataTransfer?.files?.length > 0) { handleFileUpload(e.dataTransfer.files[0]); } }); } else { console.error("File drop element not found"); } if (fileInputElement) { fileInputElement.addEventListener("change", e => { if (e.target instanceof HTMLInputElement && e.target.files?.length > 0) { handleFileUpload(e.target.files[0]); e.target.value = ''; } }); } else { console.error("File input element not found"); } gainAdjustSlider?.addEventListener("input", () => { if(gainAdjustValue && gainAdjustSlider) gainAdjustValue.textContent = gainAdjustSlider.value + " dB"; }); zoomSlider?.addEventListener("input", () => { if (!wavesurfer || !currentBuffer) return; const zoomVal = parseInt(zoomSlider.value); if (zoomValue) zoomValue.textContent = zoomVal; const minPxPerSec = 10, maxPxPerSec = 5000, range = maxPxPerSec - minPxPerSec; const scaledZoom = minPxPerSec + Math.pow(zoomVal / 500, 2) * range; wavesurfer.zoom(scaledZoom); }); console.log("UI event listeners initialized."); }
        function initTransportControls() { document.getElementById("play-btn")?.addEventListener("click", () => { if (!wavesurfer || !currentBuffer) return; const region = getSelectedRegion(); if (region) wavesurfer.play(region.start, region.end); else wavesurfer.play(); }); document.getElementById("pause-btn")?.addEventListener("click", () => { wavesurfer?.pause(); }); document.getElementById("stop-btn")?.addEventListener("click", () => { wavesurfer?.stop(); }); document.getElementById("save-wav-44-btn")?.addEventListener("click", () => saveAsWav(44100)); document.getElementById("save-wav-48-btn")?.addEventListener("click", () => saveAsWav(48000)); /* MP3 listener removed */ document.getElementById("loop-btn")?.addEventListener("click", () => { if (!currentBuffer) return; loopEnabled = !loopEnabled; const loopBtn = document.getElementById("loop-btn"); if (loopBtn) loopBtn.textContent = loopEnabled ? "Loop: On" : "Loop: Off"; setStatus(`Loop ${loopEnabled ? "enabled" : "disabled"}`); const region = getSelectedRegion(); if (region && wavesurfer?.regions?.list[region.id]) wavesurfer.regions.list[region.id].loop = loopEnabled; }); document.getElementById("select-all-btn")?.addEventListener("click", selectAll); document.getElementById("select-none-btn")?.addEventListener("click", clearSelection); document.getElementById("cut-btn")?.addEventListener("click", cutSelection); document.getElementById("reverse-btn")?.addEventListener("click", reverseAudio); document.getElementById("normalize-btn")?.addEventListener("click", normalizeAudio); document.getElementById("gain-apply-btn")?.addEventListener("click", applyGain); document.getElementById("fade-in-btn")?.addEventListener("click", fadeInAudio); document.getElementById("fade-out-btn")?.addEventListener("click", fadeOutAudio); console.log("Transport/effect control listeners initialized."); }

        // --- UI Update Functions ---
        function showProcessing(message = "Processing...", showProgress = false) { if (!processingOverlay || !processingMessage || !processingProgressContainer || !processingProgressBar) return; processingMessage.textContent = message; processingProgressContainer.style.display = showProgress ? "block" : "none"; processingProgressBar.style.width = "0%"; processingOverlay.style.display = "flex"; allButtonsAndSliders?.forEach(el => el.disabled = true); if (fileDropElement) fileDropElement.style.pointerEvents = 'none'; setStatus(message); }
        function updateProcessingProgress(percentage) { if (processingProgressBar) { const clampedPercentage = Math.max(0, Math.min(100, percentage)); processingProgressBar.style.width = `${clampedPercentage}%`; } }
        function hideProcessing() { if (processingOverlay) processingOverlay.style.display = "none"; enableControls(); if (fileDropElement) fileDropElement.style.pointerEvents = 'auto'; }
        function setStatus(message) { if (statusBarElement) statusBarElement.textContent = message; console.log("Status:", message); }
        function updateFileInfo() { if (!fileInfoElement) return; if (!currentBuffer) { fileInfoElement.textContent = "No file loaded"; return; } try { const duration = currentBuffer.duration, sampleRate = currentBuffer.sampleRate, channels = currentBuffer.numberOfChannels, bitDepth = 16, durationStr = formatTime(duration); fileInfoElement.textContent = `File: ${currentFileName} | ${durationStr} | ${sampleRate} Hz | ${channels} ch | ${bitDepth}-bit`; } catch (error) { console.error("Error updating file info:", error); fileInfoElement.textContent = `File: ${currentFileName} | Error retrieving details`; } }
        function formatTime(seconds) { if (isNaN(seconds) || seconds === null || seconds === undefined || seconds < 0) return "0:00"; const totalSeconds = Math.floor(seconds), minutes = Math.floor(totalSeconds / 60), secs = totalSeconds % 60; return `${minutes}:${secs < 10 ? "0" : ""}${secs}`; }
        function updateTimeDisplay() { if (timeDisplayElement && wavesurfer) { const currentTime = wavesurfer.getCurrentTime() || 0, duration = wavesurfer.getDuration() || 0; timeDisplayElement.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`; } else if (timeDisplayElement) { timeDisplayElement.textContent = "0:00 / 0:00"; } }

        // --- Control Enable/Disable Logic ---
        function enableControls() {
             const audioLoaded = !!currentBuffer; const regionSelected = !!getSelectedRegion();
             const isPlaying = wavesurfer && wavesurfer.isPlaying();
             // No external library checks needed now
             // console.log(`--- Running enableControls ---`);
             // console.log(`States: audioLoaded=${audioLoaded}, regionSelected=${!!regionSelected}, isPlaying=${isPlaying}`);

             allButtonsAndSliders?.forEach(el => {
                 let disable = false;
                 if (!audioLoaded) { const allowWithoutAudio = ['file-input', 'file-drop']; if (!allowWithoutAudio.includes(el.id) && (el.classList.contains('btn') || el.type === 'range')) disable = true; }
                 if (!disable) {
                     switch (el.id) {
                         case 'play-btn': disable = isPlaying; break;
                         case 'pause-btn': disable = !isPlaying; break;
                         // Save buttons require audio loaded
                         case 'save-wav-44-btn': case 'save-wav-48-btn': disable = !audioLoaded; break;
                         // MP3 button removed
                         case 'select-none-btn': case 'cut-btn': case 'fade-in-btn': case 'fade-out-btn': disable = !regionSelected; break;
                         // Default controls just need audio loaded (handled by initial check)
                     }
                 }
                 if (el.disabled !== disable) el.disabled = disable; else if (disable && !el.disabled) el.disabled = true;
             });
             if (fileDropElement && processingOverlay && processingOverlay.style.display === 'none') fileDropElement.style.pointerEvents = 'auto';
            // console.log("--- Finished enableControls ---");
         }

        // --- File Handling & Buffer Copy ---
        function handleFileUpload(file) { if (!file) { setStatus("Error: No file selected"); return; } const fileType = file.type, fileNameLower = file.name.toLowerCase(); if (!fileType.match(/audio\/(wav|wave|x-wav)/i) && !fileNameLower.endsWith(".wav")) { setStatus("Error: Please select a valid WAV file (.wav)"); console.warn(`Rejected file: ${file.name}, type: ${file.type}`); return; } currentFileName = file.name; setStatus("Loading file: " + currentFileName); showProcessing("Loading and Decoding...", true); updateProcessingProgress(5); if (!audioContext) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized on demand."); } catch (error) { setStatus("Fatal Error: Web Audio API not supported."); console.error("Web Audio API error:", error); hideProcessing(); enableControls(); return; } } const reader = new FileReader(); reader.onload = (e) => { if (!e.target || !e.target.result || !(e.target.result instanceof ArrayBuffer)) { setStatus("Error reading file: Invalid result."); console.error("FileReader onload error."); hideProcessing(); enableControls(); return; } try { const arrayBuffer = e.target.result; updateProcessingProgress(30); console.log("File read, decoding..."); setStatus("Decoding audio data..."); audioContext.decodeAudioData(arrayBuffer).then(buffer => { updateProcessingProgress(70); console.log("Audio decoded."); originalBuffer = buffer; currentBuffer = createBufferCopy(buffer); if (!currentBuffer) throw new Error("Failed to copy buffer."); wavesurfer?.loadDecodedBuffer(currentBuffer); updateProcessingProgress(95); }).catch(error => { let errorMsg = `Error decoding audio: ${error.message}.`; if (error.message.toLowerCase().includes('encoding')) errorMsg += " File corrupt/unsupported format?"; else errorMsg += " Valid WAV?"; setStatus(errorMsg); console.error("Decode Error:", error); currentBuffer = null; originalBuffer = null; updateFileInfo(); updateTimeDisplay(); hideProcessing(); enableControls(); }); } catch (error) { setStatus(`Error processing file data: ${error.message}`); console.error("File Processing Error:", error); currentBuffer = null; originalBuffer = null; updateFileInfo(); updateTimeDisplay(); hideProcessing(); enableControls(); } }; reader.onerror = (event) => { const error = event.target?.error || new Error("Unknown FileReader error"); setStatus(`Error reading file: ${error.message}`); console.error("FileReader Error:", error); hideProcessing(); enableControls(); }; reader.onprogress = (event) => { if (event.lengthComputable) { let percentComplete = 5 + Math.round((event.loaded / event.total) * 25); updateProcessingProgress(percentComplete); } }; reader.readAsArrayBuffer(file); }
        function createBufferCopy(sourceBuffer) { if (!audioContext) { console.error("Cannot copy: No AudioContext."); setStatus("Error: Audio system not ready."); return null; } if (!sourceBuffer || !(sourceBuffer instanceof AudioBuffer)) { console.error("Cannot copy: Invalid sourceBuffer."); setStatus("Error: Cannot copy invalid audio."); return null; } try { const newBuffer = audioContext.createBuffer(sourceBuffer.numberOfChannels, sourceBuffer.length, sourceBuffer.sampleRate); for (let channel = 0; channel < sourceBuffer.numberOfChannels; channel++) { const channelData = sourceBuffer.getChannelData(channel); newBuffer.copyToChannel(channelData, channel, 0); } return newBuffer; } catch (error) { console.error("Error copying AudioBuffer:", error); setStatus("Error: Failed to duplicate audio data."); return null; } }

        // --- Selection Functions ---
        function getSelectedRegion() { const rl = wavesurfer?.regions?.list; if (!rl) return null; const rids = Object.keys(rl); return rids.length > 0 ? rl[rids[0]] : null; }
        function selectAll() { if (!wavesurfer || !currentBuffer) return; const duration = wavesurfer.getDuration(); if (duration <= 0) return; clearSelection(); wavesurfer.addRegion({ start: 0, end: duration, drag: false, resize: true, color: "rgba(231, 111, 81, 0.3)", loop: loopEnabled }); setStatus("Selected all"); enableControls(); }
        function clearSelection() { wavesurfer?.regions?.clear(); enableControls(); }

        // --- Core Audio Processing ---
        function applyProcessing(operationName, processFn, isDestructive = false) { if (!currentBuffer || !audioContext) { setStatus(`Error: No audio loaded for ${operationName}`); return; } const region = getSelectedRegion(); let startSample = 0, endSample = currentBuffer.length, statusMsg = `Applying ${operationName} to entire file...`; if (region) { startSample = Math.max(0, Math.floor(region.start * currentBuffer.sampleRate)); endSample = Math.min(currentBuffer.length, Math.floor(region.end * currentBuffer.sampleRate)); if (startSample >= endSample) { setStatus(`Cannot apply ${operationName}: Invalid selection.`); return; } statusMsg = `Applying ${operationName} to selection (${formatTime(region.start)} - ${formatTime(region.end)})...`; } showProcessing(`Applying ${operationName}...`, false); setTimeout(() => { let processedBuffer = null; try { let bufferToProcess = isDestructive ? currentBuffer : createBufferCopy(currentBuffer); if (!bufferToProcess) throw new Error("Failed to get buffer for processing."); processedBuffer = processFn(bufferToProcess, startSample, endSample); if (processedBuffer instanceof AudioBuffer) { currentBuffer = processedBuffer; console.log(`${operationName} OK, updating WS.`); wavesurfer?.loadDecodedBuffer(currentBuffer); updateFileInfo(); setStatus(`${operationName} applied.`); if (isDestructive && operationName === 'Cut') clearSelection(); } else { console.log(`${operationName} returned null/invalid.`); setStatus(`${operationName} completed (no change/error).`); hideProcessing(); } } catch (error) { setStatus(`Error applying ${operationName}: ${error.message}`); console.error(`${operationName} Error in applyProcessing:`, error); hideProcessing(); } }, 50); }
        function cutSelection() { applyProcessing("Cut", (buffer, startSample, endSample) => { if (!audioContext) return null; const originalLength = buffer.length, channels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, cutLength = endSample - startSample, newLength = originalLength - cutLength; if (newLength <= 0) return audioContext.createBuffer(channels, 1, sampleRate); try { const newBuffer = audioContext.createBuffer(channels, newLength, sampleRate); for (let ch = 0; ch < channels; ch++) { const oldData = buffer.getChannelData(ch), newData = newBuffer.getChannelData(ch); const segmentBefore = oldData.subarray(0, startSample); newData.set(segmentBefore, 0); const segmentAfter = oldData.subarray(endSample); newData.set(segmentAfter, startSample); } return newBuffer; } catch (error) { console.error("Cut Error:", error); setStatus("Error cutting."); return null; } }, true); }
        function reverseAudio() { applyProcessing("Reverse", (buffer, startSample, endSample) => { try { for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const channelData = buffer.getChannelData(ch), sectionToReverse = channelData.slice(startSample, endSample); sectionToReverse.reverse(); channelData.set(sectionToReverse, startSample); } return buffer; } catch (error) { console.error("Reverse Error:", error); setStatus("Error reversing."); return null; } }); }
        function normalizeAudio() { applyProcessing("Normalize", (buffer, startSample, endSample) => { try { let maxAmp = 0; for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); for (let i = startSample; i < endSample; i++) maxAmp = Math.max(maxAmp, Math.abs(data[i])); } if (maxAmp === 0) return buffer; const targetMaxAmp = 0.95, gainFactor = targetMaxAmp / maxAmp; for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); for (let i = startSample; i < endSample; i++) data[i] *= gainFactor; } return buffer; } catch(error) { console.error("Normalize Error:", error); setStatus("Error normalizing."); return null; } }); }
        function applyGain() { if (!gainAdjustSlider) return; const gainDb = parseFloat(gainAdjustSlider.value), gainFactor = Math.pow(10, gainDb / 20); applyProcessing(`Gain (${gainDb} dB)`, (buffer, startSample, endSample) => { try { if (gainFactor === 1) return buffer; for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); for (let i = startSample; i < endSample; i++) data[i] *= gainFactor; } return buffer; } catch (error) { console.error("Gain Error:", error); setStatus("Error applying gain."); return null; } }); }
        function fadeInAudio() { applyProcessing("Fade In", (buffer, startSample, endSample) => { try { const fadeLength = endSample - startSample; if (fadeLength <= 0) return buffer; for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); for (let i = startSample; i < endSample; i++) { const gain = (i - startSample) / fadeLength; data[i] *= gain; } } return buffer; } catch (error) { console.error("FadeIn Error:", error); setStatus("Error applying fade in."); return null; } }); }
        function fadeOutAudio() { applyProcessing("Fade Out", (buffer, startSample, endSample) => { try { const fadeLength = endSample - startSample; if (fadeLength <= 0) return buffer; for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); for (let i = startSample; i < endSample; i++) { const gain = 1.0 - ((i - startSample) / fadeLength); data[i] *= gain; } } return buffer; } catch (error) { console.error("FadeOut Error:", error); setStatus("Error applying fade out."); return null; } }); }

        // --- Save Functionality ---
        /** Saves current buffer as WAV at specified sample rate */
        function saveAsWav(targetSampleRate = 44100) { if (!currentBuffer || !audioContext) { setStatus("No audio to save"); return; } const rateString = targetSampleRate === 48000 ? "48kHz" : "44.1kHz"; showProcessing(`Preparing WAV (${rateString})...`, true); setStatus(`Saving audio as WAV (${rateString})...`); updateProcessingProgress(5); setTimeout(async () => { try { let bufferToSave = currentBuffer; if (currentBuffer.sampleRate !== targetSampleRate) { setStatus(`Resampling to ${targetSampleRate}Hz...`); console.log(`Resampling from ${currentBuffer.sampleRate}Hz to ${targetSampleRate}Hz...`); updateProcessingProgress(10); const resampledBuffer = await resampleBufferHQ(currentBuffer, targetSampleRate); if (!resampledBuffer) throw new Error("Resampling failed."); bufferToSave = resampledBuffer; console.log("Resampling complete."); updateProcessingProgress(40); setStatus("Resampling complete. Encoding WAV..."); } else { console.log(`Sample rate already ${targetSampleRate}Hz.`); updateProcessingProgress(40); setStatus("Encoding WAV..."); } console.log("Encoding WAV blob..."); const wavBlob = audioBufferToWavBlob(bufferToSave); if (!wavBlob) throw new Error("Failed to encode WAV."); console.log(`WAV Blob created: size=${wavBlob.size}`); updateProcessingProgress(90); const url = URL.createObjectURL(wavBlob); const a = document.createElement("a"); a.style.display = "none"; a.href = url; const baseName = currentFileName.toLowerCase().endsWith('.wav') ? currentFileName.substring(0, currentFileName.length - 4) : (currentFileName || 'audio'); const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); a.download = `${baseName}_edited_${rateString}_${timestamp}.wav`; document.body.appendChild(a); console.log(`Triggering download: ${a.download}`); a.click(); setTimeout(() => { try { document.body.removeChild(a); URL.revokeObjectURL(url); console.log("Download link cleaned up."); } catch (cleanupError) { console.warn("Cleanup error:", cleanupError); } setStatus(`WAV file (${rateString}) saved successfully`); updateProcessingProgress(100); hideProcessing(); }, 200); } catch (error) { setStatus(`Error saving WAV: ${error.message}`); console.error("Save WAV Error:", error); hideProcessing(); } }, 50); }
        // saveAsMp3 function REMOVED
        /** Resamples using OfflineAudioContext (Higher Quality) */
        async function resampleBufferHQ(buffer, targetSampleRate) { if (!audioContext) { console.error("Resampling failed: No AudioContext."); setStatus("Error: Audio system not ready."); return null; } if (buffer.sampleRate === targetSampleRate) { return buffer; } const originalLength = buffer.length, numChannels = buffer.numberOfChannels; const newLength = Math.round(originalLength * targetSampleRate / buffer.sampleRate); if (newLength <= 0) { console.error("Resampling failed: Invalid new length."); setStatus("Error: Resampling resulted in invalid length."); return null; } try { const offlineCtx = new OfflineAudioContext(numChannels, newLength, targetSampleRate); const bufferSource = offlineCtx.createBufferSource(); bufferSource.buffer = buffer; bufferSource.connect(offlineCtx.destination); bufferSource.start(0); console.log(`Starting offline rendering for resampling to ${targetSampleRate}Hz...`); const resampled = await offlineCtx.startRendering(); console.log("Offline rendering complete."); return resampled; } catch (error) { console.error("Error during HQ resampling:", error); console.warn("OfflineAudioContext resampling failed, falling back to linear interpolation."); setStatus(`Warning: Resampling quality reduced. ${error.message}`); return resampleBufferLinear(buffer, targetSampleRate); } }
        /** Resamples using linear interpolation (Fallback) */
        function resampleBufferLinear(buffer, targetSampleRate) { if (!audioContext) return null; const numChannels = buffer.numberOfChannels, originalLength = buffer.length, originalSampleRate = buffer.sampleRate; if (originalSampleRate <=0 || targetSampleRate <= 0) { console.error(`Linear Resampling fail: Invalid rate(s)`); return null; } const newLength = Math.round(originalLength * targetSampleRate / originalSampleRate); if (newLength <= 0) { console.error("Linear Resampling fail: Invalid new length."); return null; } try { const newBuffer = audioContext.createBuffer(numChannels, newLength, targetSampleRate); const ratio = originalSampleRate / targetSampleRate; for (let ch = 0; ch < numChannels; ch++) { const oldData = buffer.getChannelData(ch), newData = newBuffer.getChannelData(ch); for (let i = 0; i < newLength; i++) { const oldPosition = i * ratio, index1 = Math.floor(oldPosition), index2 = Math.min(index1 + 1, originalLength - 1), weight = oldPosition - index1; newData[i] = oldData[index1] * (1 - weight) + oldData[index2] * weight; } } console.log("Linear interpolation resampling complete."); return newBuffer; } catch (error) { console.error("Linear Resampling Error:", error); setStatus(`Error resampling: ${error.message}`); return null; } }
        /** Converts AudioBuffer to WAV Blob */
        function audioBufferToWavBlob(buffer) { if (!buffer || !(buffer instanceof AudioBuffer)) { console.error("WAV Fail: Invalid Buffer."); return null; } try { const numChannels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, numSamples = buffer.length, bytesPerSample = 2, blockAlign = numChannels * bytesPerSample, byteRate = sampleRate * blockAlign, dataSize = numSamples * blockAlign, bufferLength = 44 + dataSize, wavBuffer = new ArrayBuffer(bufferLength), view = new DataView(wavBuffer); function writeString(offset, str) { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); } writeString(0, "RIFF"); view.setUint32(4, 36 + dataSize, true); writeString(8, "WAVE"); writeString(12, "fmt "); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bytesPerSample * 8, true); writeString(36, "data"); view.setUint32(40, dataSize, true); let offset = 44; const channelData = []; for(let ch = 0; ch < numChannels; ch++) { channelData.push(buffer.getChannelData(ch)); } for (let i = 0; i < numSamples; i++) { for (let ch = 0; ch < numChannels; ch++) { const sampleFloat = Math.max(-1, Math.min(1, channelData[ch][i])); const sampleInt = Math.floor(sampleFloat < 0 ? sampleFloat * 32768 : sampleFloat * 32767); view.setInt16(offset, sampleInt, true); offset += bytesPerSample; } } return new Blob([view], { type: "audio/wav" }); } catch (error) { console.error("Error encoding WAV Blob:", error); setStatus("Error creating WAV data."); return null; } }

        // --- App Initialization ---
        window.addEventListener("DOMContentLoaded", () => {
            console.log("DOM loaded. Initializing editor..."); initDomReferences();
            try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log(`AudioContext OK. Rate: ${audioContext.sampleRate} Hz.`); }
            catch (e) { console.error("Web Audio API not supported.", e); setStatus("Fatal Error: Web Audio API not supported."); if(fileDropElement) fileDropElement.style.display = 'none'; document.querySelectorAll('.control-panel, .transport-controls, .waveform-container, .save-options').forEach(el => el.style.display = 'none'); return; }
            initWaveSurfer(); initEventListeners(); initTransportControls();
            if (!wavesurfer) { console.error("WaveSurfer init failed."); }
            enableControls(); // Set initial state
            setStatus("Ready - Drop or select WAV file"); console.log("Init sequence complete.");
        });

    </script>
</body>
</html>